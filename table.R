u <- c(22, 8, 31, 3, 6, 222, -2)
fl <- list(c(5, 12, 13, 11, 13, 5, 13), c("ab", "b", "a", "b", "b", "ab", "a"))
tapply(u, fl, length) # contingency table; combination of factors in list related to `u`; contains NA

table(fl) # counts NA as `0`

c <- read.table("ct.dat", header=TRUE)
c
ct <- table(c)
ct

# 1-dimensional table (counts)
table(c(5, 12, 13, 12, 8, 5))

# 3-dimensional table
v <- read.table("v.dat", header=TRUE)
v
vt <- table(v)
vt # output as series of two-dimensional tables (table of gender and race for conservatives and liberals)

# matrix/array-like operations
str(ct)
class(ct)
ct[1,]
vt[1,,]
ct[1,1]
ct/5
apply(ct, 1, sum) # `marginal` values of a variable == this variable is held constant while others are summed 
                  # labels like `No` came from the row names of the matrix whic h`table()` has produced
addmargins(ct)
dimnames(ct)

# present subset
subtable <- function(tbl, subnames) {
    # extract the full cell counts array; stored in `tblarray`
    tblarray <- unclass(tbl)
    # to get desired subarray, a subsetting expression is required -> tblarray[ index ranges ]
    # -> tblarray[c("No", "Yes"), c("No", "Yes")]
    # -> but tablearray is dynmaically sized, e.g. has multiple dimensions
    # create subarray of cell counts corresponding to subnames
    dcargs <- list(tblarray)
    ndims <- length(subnames)
    for (i in 1:ndims) {
        dcargs[[i+1]] <- subnames[[i]]
    }
    # do.call() invokes `[`-function with `dcargs` as arguments
    subarray <- do.call("[", dcargs)
    # build new   table, consisting of subarray
    dims <- lapply(subnames, length) # dimension length, rows, coulmns, layers
    subtbl <- array(subarray, dims, dimnames=subnames)
    class(subtbl) <- "table"
    return(subtbl)
}
subtable(ct, list(Vote.for.X=c("No", "Yes"), Voted.for.X.Last.Time=c("No", "Yes")))

# convert table to data.frame
as.data.frame(ct)
# find te cells with the k highest frequencies
tfreq <- function(tbl, k) {
    # create data.fram frok table, adding column `Freq`
    tbldf <- as.data.frame(tbl)
    # order the entries according to the frequencies
    # `order()` returns the indices, standard way to sort a data.frame
    freqord <- order(tbldf$Freq, decreasing=TRUE)
    # create new data.frame, take the first `k` rows
    dom <- tbldf[freqord,][1:k,]
    return(dom)
}
tfreq(ct, 2)

# aggregate(), calls `tapply()` for each variable in a group
a <- read.csv("abalone.data", header=TRUE)
# `a[, -1]` == data.frame without `Gender` column
# `list(a$Gender)` == factor
# `mean` == compute median on each column in each of the data.frames that are
#           generated by the grouping corresponding to the factor
aggregate(a[,-1], list(a$Gender), mean)

# cut(), generate factors, data vector and a set of bins
#        function determines which element of vector falls into which bin
x <- c(0.88, 0.18, 0.59, 0.42, 0.18, 0.01, 0.91)
x
b <- seq(from=0.0, to=1.0, by=0.1)
b
cut(x, b, labels=FALSE)
